extends Control
class_name BuildView

signal combat_requested()
signal chassis_updated(attached_parts)

# References to managers - set these in the editor
@export var game_manager: GameManager
@export var deck_manager: DeckManager
@export var turn_manager: TurnManager

# UI elements
@export var energy_label: Label
@export var heat_label: Label
@export var end_phase_button: Button
@export var clear_chassis_button: Button

# Energy and Heat Bars
@export var energy_bar: EnergyBar
@export var heat_bar: HeatBar

# Card container
@export var hand_container: Container
@export var deck_container: Control
var cards_in_hand = []

# Chassis slots
@export var head_slot: Control
@export var core_slot: Control
@export var arm_left_slot: Control
@export var arm_right_slot: Control
@export var legs_slot: Control
@export var scrapper_slot: Control
@export var utility_slot: Control

# Exported card scene
@export var card_scene: PackedScene

# Dictionary to map slot names to controls
var chassis_slots_map = {}

# Dictionary to track attached parts
var attached_parts = {}

# Managers
var chassis_manager: ChassisManager
var hand_manager: HandManager
var drag_drop_manager: DragDropManager

# Called when the node enters the scene tree for the first time
func _ready():
    # Initialize slot map
    chassis_slots_map = {
        "scrapper": scrapper_slot,
        "head": head_slot,
        "core": core_slot,
        "arm_left": arm_left_slot,
        "arm_right": arm_right_slot,
        "legs": legs_slot,
        "utility": utility_slot
    }
    
    # Initialize managers
    _initialize_managers()
    
    # Connect TurnManager to energy label if both exist
    if turn_manager and energy_label:
        turn_manager.set_energy_label(energy_label)
        turn_manager.energy_changed.connect(_on_energy_changed)
    
    # Connect to energy and heat bars
    if turn_manager and energy_bar:
        turn_manager.energy_changed.connect(_on_energy_changed_bar)
        # Initialize energy bar with current values
        energy_bar.set_energy(turn_manager.current_energy, turn_manager.max_energy)
    
    if heat_bar:
        # Connect chassis updates to heat calculation
        chassis_updated.connect(_on_chassis_updated_heat)
        # Initialize heat bar with zero values
        heat_bar.set_heat(0, 0, 10)
    
    # Setup UI elements
    setup_ui()
    
    # Initialize the build phase
    start_build_phase()

# Initialize all managers
func _initialize_managers():
    # Create chassis manager
    chassis_manager = ChassisManager.new()
    chassis_manager.initialize(chassis_slots_map, turn_manager)
    chassis_manager.chassis_updated.connect(func(parts): emit_signal("chassis_updated", parts))
    add_child(chassis_manager)
    
    # Create hand manager
    hand_manager = HandManager.new()
    hand_manager.initialize(deck_manager, hand_container, card_scene, turn_manager)
    add_child(hand_manager)
    
    # Create drag drop manager
    drag_drop_manager = DragDropManager.new()
    drag_drop_manager.initialize(chassis_manager, hand_manager, chassis_slots_map)
    add_child(drag_drop_manager)

# Set up the UI elements
func setup_ui():
    # Connect button if needed
    if end_phase_button and not end_phase_button.pressed.is_connected(Callable(self, "_on_end_phase_button_pressed")):
        end_phase_button.pressed.connect(Callable(self, "_on_end_phase_button_pressed"))
    
    # Connect clear chassis button if needed
    if clear_chassis_button and not clear_chassis_button.pressed.is_connected(Callable(self, "_on_clear_chassis_button_pressed")):
        clear_chassis_button.pressed.connect(Callable(self, "_on_clear_chassis_button_pressed"))
    
    # Initialize UI labels with default values
    if energy_label:
        energy_label.text = "Energy: 0/0"
    
    if heat_label:
        heat_label.text = "Heat: 0/0"

# Initialize the build phase
func start_build_phase():
    # Initialize turn manager for energy
    if turn_manager:
        turn_manager.initialize()
    
    # Initialize deck container visual
    setup_deck_container()
    
    # Clear hand
    hand_manager.clear_hand()
    
    # Update UI
    update_ui()
    
    # Start drawing cards sequentially with delay
    hand_manager.start_sequential_card_draw()

# Setup the visual deck container
func setup_deck_container():
    if not deck_container:
        return
    
    # Clear existing deck visuals
    for child in deck_container.get_children():
        child.queue_free()
    
    # Create deck stack visual
    create_deck_stack_visual()

# Create visual representation of the deck stack
func create_deck_stack_visual():
    if not deck_container or not deck_manager:
        return
    
    # Create a stack of card backs to represent the deck
    var deck_status = deck_manager.get_deck_status()
    var total_cards = deck_status.deck_size + deck_status.discard_size
    
    # Create main deck visual (a stack of card backs)
    var deck_visual = ColorRect.new()
    deck_visual.name = "DeckStack"
    deck_visual.color = Color(0.2, 0.3, 0.5, 0.8)  # Dark blue for deck
    deck_visual.size = Vector2(100, 150)
    deck_visual.position = Vector2(10, 10)
    
    # Add deck count label
    var count_label = Label.new()
    count_label.name = "DeckCount"
    count_label.text = str(total_cards)
    count_label.position = Vector2(35, 60)
    count_label.add_theme_font_size_override("font_size", 24)
    deck_visual.add_child(count_label)
    
    # Add deck title label
    var title_label = Label.new()
    title_label.name = "DeckTitle"
    title_label.text = "DECK"
    title_label.position = Vector2(30, 10)
    title_label.add_theme_font_size_override("font_size", 14)
    deck_visual.add_child(title_label)
    
    # Make deck clickable for drawing cards
    deck_visual.mouse_filter = Control.MOUSE_FILTER_STOP
    deck_visual.gui_input.connect(_on_deck_clicked)
    
    deck_container.add_child(deck_visual)

# Draw chassis slots (this is now more of a visual function)
func draw_chassis_slots():
    # We don't need to create slots since they're now exported controls
    # Just add some visual indicators if needed
    pass

# Update UI elements
func update_ui():
    if turn_manager:
        # TurnManager now handles energy display directly via energy_label
        if heat_label:
            heat_label.text = "Heat: 0/10"  # Placeholder for now
    else:
        if energy_label:
            energy_label.text = "Energy: 4/4"
        if heat_label:
            heat_label.text = "Heat: 0/10"

# Handle energy changes from TurnManager
func _on_energy_changed(current: int, maximum: int):
    # TurnManager updates the label directly, but we can do additional UI updates here
    pass

# Handle energy changes for the energy bar
func _on_energy_changed_bar(current: int, maximum: int):
    if energy_bar:
        energy_bar.set_energy(current, maximum)
    
    # Update card affordability in hand
    hand_manager.update_card_affordability(current)

# Handle chassis updates for heat calculation
func _on_chassis_updated_heat(_attached_parts_dict: Dictionary):
    _update_heat_display()

# Calculate and update heat display
func _update_heat_display():
    if not heat_bar or not chassis_manager:
        return
    
    # Get heat values from chassis manager
    var heat_data = chassis_manager.calculate_heat()
    
    # Update the heat bar
    heat_bar.set_heat(heat_data.needed_heat, heat_data.scrapper_heat, heat_data.max_heat)

# Handle button press to end the build phase
func _on_end_phase_button_pressed():
    # Build robot and start combat through TurnManager
    if turn_manager and turn_manager.has_method("build_robot_and_start_combat"):
        turn_manager.build_robot_and_start_combat(self, game_manager)
    else:
        # Fallback to old behavior
        emit_signal("combat_requested")

# Handle button press to clear all chassis parts
func _on_clear_chassis_button_pressed():
    # Use chassis manager to clear parts
    var returned_cards = chassis_manager.clear_all_chassis_parts()
    
    # Return all cards to hand
    for card in returned_cards:
        await hand_manager.return_card_to_hand(card)

# Update the deck visual counter
func update_deck_visual():
    if not deck_container:
        return
    
    var deck_stack = deck_container.get_node_or_null("DeckStack")
    if not deck_stack:
        return
    
    var count_label = deck_stack.get_node_or_null("DeckCount")
    if not count_label:
        return
    
    var deck_status = deck_manager.get_deck_status()
    var total_cards = deck_status.deck_size + deck_status.discard_size
    count_label.text = str(total_cards)

# Handle deck container clicks to draw cards
func _on_deck_clicked(event):
    if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
        hand_manager.draw_single_card()
        update_deck_visual()

# Handle card drop event - delegate to drag_drop_manager
func _handle_card_drop(card, drop_pos, target = null):
    drag_drop_manager.handle_card_drop(card, drop_pos, target)

# Handle card drag event - delegate to drag_drop_manager
func _handle_card_drag(card):
    drag_drop_manager.handle_card_drag(card)

# Return card to hand - delegate to hand_manager
func _return_card_to_hand(card):
    return hand_manager.return_card_to_hand(card)
